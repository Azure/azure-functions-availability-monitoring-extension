using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Azure.AvailabilityMonitoring;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.AvailabilityMonitoring;
using Microsoft.Extensions.Logging;

namespace AvailabilityMonitoring_Extension_DemoFunction
{
    // This is an example for how the scaffolded code generated by selecting a Function template might look like.
    // Template parameters are assigned in the body of Run(..).
    // The user is then expected to modify the ValidateResponseAsync(..) method.
    // Of course, they can modify more, bit focussing on should be the success pit.
    // In this example we let the user copletely valudate the response, but we ca use template paramaters for that too.

    public static class CatMonitoredApiIsAvailable
    {
        [FunctionName("Monitored-API-is-available")]
        [return: AvailabilityTestResult]
        public static async Task<bool> Run(
                    [TimerTrigger(AvailabilityTestInterval.Minute01)] TimerInfo notUsed,
                    ILogger log)
        {
            // User-specified test parameters:

            string monitoredApiUrl = "http://availabilitymonitoring-extension-monitoredappsample02.azurewebsites.net/api/Time?source=CatMonitoredApiIsAvailable";
            HttpMethod httpMethod = HttpMethod.Get;
            KeyValuePair<string, string>[] headers = new KeyValuePair<string, string>[] {
            };
            string payload = null;
            TimeSpan overallTimeout = TimeSpan.FromSeconds(30);

            // Needs to be set for the result:
            bool isAvailabilityTestSuccessful;
            
            // Initialize an HTTP client and set default headers:
            using (var timeoutController = new CancellationTokenSource(overallTimeout))
            using (HttpClient http = AvailabilityTest.NewHttpClient())
            {
                CancellationToken timeoutControl = timeoutController.Token;

                // Run the request and get the response:
                using (HttpResponseMessage response = await ExecuteRequestAsync(http, monitoredApiUrl, httpMethod, headers, payload, log, timeoutControl))
                {
                    isAvailabilityTestSuccessful = await ValidateResponseAsync(response, log, timeoutControl);
                }

            }

            return isAvailabilityTestSuccessful;
        }

        private static async Task<HttpResponseMessage> ExecuteRequestAsync(
                    HttpClient http,
                    string monitoredApiUrl, 
                    HttpMethod httpMethod, 
                    IList<KeyValuePair<string, string>> headers,
                    string payload,
                    ILogger log,
                    CancellationToken timeoutControl)
        {
            log.LogInformation("Preparing request to the monitored URL:"
                             + " {{ MonitoredUrl = {MonitoredUrl},"
                             + " HttpMethod = {HttpMethod},"
                             + " CustomHeaderCount = {CustomRequestHeaderCount},"
                             + " PayloadLength = {PayloadLength} }}",
                               monitoredApiUrl,
                               httpMethod.ToString(),
                               headers?.Count ?? 0,
                               payload?.Length ?? 0);

            using (HttpRequestMessage request = new HttpRequestMessage(httpMethod, monitoredApiUrl))
            {
                if (headers != null)
                {
                    foreach(KeyValuePair<string, string> header in headers)
                    {
                        if (! String.IsNullOrWhiteSpace(header.Key))
                        {
                            request.Headers.Add(header.Key, header.Value ?? String.Empty);
                        }
                    }
                }

                if (payload != null)
                {
                    request.Content = new StringContent(payload, Encoding.UTF8);
                }

                log.LogInformation("Initiating request.");
                Task<HttpResponseMessage> requestTask = http.SendAsync(request, timeoutControl);

                log.LogInformation("Request initiated. Awaiting response.");
                HttpResponseMessage response = await requestTask;

                if (response == null)
                {
                    log.LogInformation("Response received, but it was NULL.");
                    return null;
                }

                KeyValuePair<string, IEnumerable<string>>[] responseHeaders = response.Headers?.ToArray();

                log.LogInformation("Response received:"
                                 + " {{ StatusCodeString = \"{StatusCodeString}\","
                                 + " StatusCodeNumber = {StatusCodeNumber},"
                                 + " ReasonPhrase = \"{ReasonPhrase}\","
                                 + " ResponseHeaderCount = {ResponseHeaderCount}}}",
                                   response.StatusCode.ToString(),
                                   (int) (response.StatusCode),
                                   response.ReasonPhrase,
                                   responseHeaders?.Length ?? 0);

                if (responseHeaders != null)
                {
                    foreach(KeyValuePair<string, IEnumerable<string>> header in responseHeaders)
                    {
                        string name = header.Key ?? "null";

                        var value = new StringBuilder();

                        if (header.Value != null)
                        {
                            foreach(string v in header.Value)
                            {
                                if (value.Length > 0)
                                {
                                    value.Append(", ");
                                }

                                if (v == null)
                                {
                                    value.Append("null");
                                }
                                else
                                {
                                    value.Append('"');
                                    value.Append(v);
                                    value.Append('"');
                                }
                            }
                        }

                        log.LogInformation("Response header parsed: {{ Name = \'{Name}\', Value = \'{Value}\' }}", name, value.ToString());
                    }
                }

                return response;
            }
        }

        private static async Task<bool> ValidateResponseAsync(
                    HttpResponseMessage response,
                    ILogger log,
                    CancellationToken timeoutControl)
        {
            // Add code here to validate the response:

            response.EnsureSuccessStatusCode();
            string responseContent = await response.Content.ReadAsStringAsync();

            bool hasExpectedContent = responseContent.Contains("localTime", StringComparison.OrdinalIgnoreCase)
                                        && responseContent.Contains("publicTime", StringComparison.OrdinalIgnoreCase)
                                        && responseContent.Contains("functionTime", StringComparison.OrdinalIgnoreCase)
                                        && (responseContent.Contains("\"version\": \"4\"", StringComparison.OrdinalIgnoreCase)
                                            || responseContent.Contains("\"version\":\"4\"", StringComparison.OrdinalIgnoreCase));
            return hasExpectedContent;
        }

      
    }
}
